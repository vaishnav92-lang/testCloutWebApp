generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                     String                @id @default(cuid())
  email                  String                @unique
  emailVerified          DateTime?
  firstName              String?
  lastName               String?
  profileImage           String?
  phone                  String?
  location               String?
  linkedinUrl            String?
  bio                    String?
  skills                 String[]              @default([])
  experience             String?
  isProfileComplete      Boolean               @default(false)
  referralCode           String                @unique @default(cuid())
  referredById           String?
  inviteToken            String?               @unique
  inviteUsed             Boolean               @default(false)
  invitedAt              DateTime?
  createdAt              DateTime              @default(now())
  updatedAt              DateTime              @updatedAt
  userIntent             UserIntent            @default(ACTIVELY_LOOKING)
  availableInvites       Int                   @default(3)
  charityDonated         Float                 @default(0.0)
  engagementLevel        EngagementLevel       @default(ACTIVE_SEEKER)
  reputationScore        Float                 @default(0.0)
  tier                   NodeTier              @default(CONNECTOR)
  totalInvitesUsed       Int                   @default(0)
  userType               UserType              @default(REFERRER)
  isHiringManager        Boolean               @default(false)
  cloutScore             Float                 @default(0.0)
  endorsementsScore      Float                 @default(0.0)
  networkValue           Float                 @default(0.0)
  pendingEarnings        Float                 @default(0.0)
  successfulReferrals    Int                   @default(0)
  totalEarnings          Float                 @default(0.0)
  isAdmin                Boolean               @default(false)
  allocatedTrust         Int                   @default(0)
  availableTrust         Int                   @default(100)
  totalTrustPoints       Int                   @default(100)
  cloutPercentile        Int                   @default(0)
  accounts               Account[]
  cloutActivities        CloutActivity[]
  earningsTransactions   EarningsTransaction[]
  endorsementReleases    EndorsementRelease[]
  endorsementsReceived   Endorsement[]         @relation("EndorsementReceived")
  endorsementsGiven      Endorsement[]         @relation("EndorsementGiven")
  introductionsMade      Introduction[]        @relation("IntroductionMaker")
  introductionsAsPersonA Introduction[]        @relation("IntroductionPersonA")
  introductionsAsPersonB Introduction[]        @relation("IntroductionPersonB")
  receivedInvitations    Invitation[]          @relation("InviteReceiver")
  sentInvitations        Invitation[]          @relation("InviteSender")
  applications           JobApplication[]
  ownedJobs              Job[]
  relationshipsAsUser1   Relationship[]        @relation("RelationshipUser1")
  relationshipsAsUser2   Relationship[]        @relation("RelationshipUser2")
  sessions               Session[]
  referredBy             User?                 @relation("UserReferrals", fields: [referredById], references: [id])
  referrals              User[]                @relation("UserReferrals")

  // EigenTrust relations
  trustAllocationsGiven    TrustAllocation[]   @relation("TrustGiver")
  trustAllocationsReceived TrustAllocation[]   @relation("TrustReceiver")
  computedTrustScore       ComputedTrustScore?

  @@map("users")
}

model Invitation {
  id          String           @id @default(cuid())
  email       String
  trustScore  Int
  status      InvitationStatus @default(PENDING)
  senderId    String
  receiverId  String?
  sentAt      DateTime         @default(now())
  respondedAt DateTime?
  receiver    User?            @relation("InviteReceiver", fields: [receiverId], references: [id])
  sender      User             @relation("InviteSender", fields: [senderId], references: [id])

  @@unique([senderId, email])
  @@map("invitations")
}

model Relationship {
  id                  String             @id @default(cuid())
  user1Id             String
  user2Id             String
  user1TrustScore     Int?
  user2TrustScore     Int?
  status              RelationshipStatus @default(PENDING)
  createdAt           DateTime           @default(now())
  updatedAt           DateTime           @updatedAt
  user1TrustAllocated Int                @default(0)
  user2TrustAllocated Int                @default(0)
  user1               User               @relation("RelationshipUser1", fields: [user1Id], references: [id])
  user2               User               @relation("RelationshipUser2", fields: [user2Id], references: [id])

  @@unique([user1Id, user2Id])
  @@map("relationships")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

model Company {
  id          String   @id @default(cuid())
  name        String
  description String?
  website     String?
  logoUrl     String?
  industry    String?
  size        String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  jobs        Job[]

  @@map("companies")
}

model Job {
  id                   String                @id @default(cuid())
  title                String
  description          String?
  requirements         String[]              @default([])
  location             String?
  remote               Boolean               @default(false)
  salaryMin            Int?
  salaryMax            Int?
  currency             String                @default("USD")
  companyId            String
  ownerId              String
  createdAt            DateTime              @default(now())
  updatedAt            DateTime              @updatedAt
  archetypes           String?
  commonMismatches     String?
  dayToDayDescription  String?
  equityOffered        Boolean               @default(false)
  equityRange          String?
  excitingWork         String?
  flexibleRequirements String?
  growthPath           String?
  locationCity         String?
  locationType         LocationType          @default(REMOTE)
  mustHaves            String?
  nonWorkSignals       String?
  publishedAt          DateTime?
  referralBudget       Int?
  referralPreference   ReferralPreference    @default(MANUAL_SCREEN)
  roleChallenges       String?
  specialOpportunity   String?
  workingStyle         String?
  status               JobPostingStatus      @default(DRAFT)
  cloutActivities      CloutActivity[]
  earningsTransactions EarningsTransaction[]
  endorsementReleases  EndorsementRelease[]
  applications         JobApplication[]
  company              Company               @relation(fields: [companyId], references: [id])
  owner                User                  @relation(fields: [ownerId], references: [id])

  @@map("jobs")
}

model JobApplication {
  id        String            @id @default(cuid())
  status    ApplicationStatus @default(APPLIED)
  userId    String
  jobId     String
  appliedAt DateTime          @default(now())
  updatedAt DateTime          @updatedAt
  job       Job               @relation(fields: [jobId], references: [id])
  user      User              @relation(fields: [userId], references: [id])

  @@unique([userId, jobId])
  @@map("job_applications")
}

model Endorsement {
  id                   String               @id @default(cuid())
  endorserId           String
  endorsedUserId       String?
  endorsedUserEmail    String
  endorsementContent   String
  videoUrl             String?
  status               EndorsementStatus    @default(PENDING_CANDIDATE_ACTION)
  candidateNotifiedAt  DateTime?
  candidateRespondedAt DateTime?
  createdAt            DateTime             @default(now())
  updatedAt            DateTime             @updatedAt
  cloutActivities      CloutActivity[]
  releases             EndorsementRelease[]
  endorsedUser         User?                @relation("EndorsementReceived", fields: [endorsedUserId], references: [id])
  endorser             User                 @relation("EndorsementGiven", fields: [endorserId], references: [id])

  @@unique([endorserId, endorsedUserEmail])
  @@map("endorsements")
}

model EndorsementRelease {
  id            String      @id @default(cuid())
  endorsementId String
  employerId    String
  jobId         String?
  releasedBy    ReleaseType
  releasedAt    DateTime    @default(now())
  employer      User        @relation(fields: [employerId], references: [id])
  endorsement   Endorsement @relation(fields: [endorsementId], references: [id], onDelete: Cascade)
  job           Job?        @relation(fields: [jobId], references: [id])

  @@map("endorsement_releases")
}

model EarningsTransaction {
  id            String         @id @default(cuid())
  userId        String
  amount        Float
  type          EarningsType
  status        EarningsStatus @default(PENDING)
  jobId         String?
  description   String?
  metadata      Json?
  paidAt        DateTime?
  paymentMethod String?
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  job           Job?           @relation(fields: [jobId], references: [id])
  user          User           @relation(fields: [userId], references: [id])

  @@map("earnings_transactions")
}

model CloutActivity {
  id            String            @id @default(cuid())
  userId        String
  activity      CloutActivityType
  pointsAwarded Float
  description   String
  jobId         String?
  endorsementId String?
  createdAt     DateTime          @default(now())
  endorsement   Endorsement?      @relation(fields: [endorsementId], references: [id])
  job           Job?              @relation(fields: [jobId], references: [id])
  user          User              @relation(fields: [userId], references: [id])

  @@map("clout_activities")
}

model Introduction {
  id             String             @id @default(cuid())
  personAId      String
  personBId      String
  introducedById String
  context        String
  status         IntroductionStatus @default(PENDING)
  notes          String?
  createdAt      DateTime           @default(now())
  establishedAt  DateTime?
  updatedAt      DateTime           @updatedAt
  introducedBy   User               @relation("IntroductionMaker", fields: [introducedById], references: [id])
  personA        User               @relation("IntroductionPersonA", fields: [personAId], references: [id])
  personB        User               @relation("IntroductionPersonB", fields: [personBId], references: [id])

  @@unique([personAId, personBId])
  @@map("introductions")
}

model SystemConfig {
  id                   String    @id @default("system_config")
  eigentrustAlpha      Float     @default(0.15)
  maxIterations        Int       @default(100)
  convergenceThreshold Float     @default(0.000001)
  adminEmail           String    @default("vaishnav@cloutcareers.com")
  lastTrustComputation DateTime?
  lastComputationTime  Int?
  lastIterations       Int?
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt

  @@map("system_config")
}

enum JobStatus {
  ACTIVE
  PAUSED
  CLOSED
}

enum ApplicationStatus {
  APPLIED
  REVIEWING
  INTERVIEWING
  OFFERED
  REJECTED
  WITHDRAWN
}

enum UserIntent {
  RECOMMEND_ONLY
  HYBRID
  ACTIVELY_LOOKING
}

enum UserType {
  CLIENT
  REFERRER
}

enum EngagementLevel {
  PURE_REFERRER
  HYBRID
  ACTIVE_SEEKER
}

enum NodeTier {
  CONNECTOR
  TALENT_SCOUT
  NETWORK_HUB
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  DECLINED
  EXPIRED
}

enum RelationshipStatus {
  PENDING
  CONFIRMED
  DECLINED
}

enum EndorsementStatus {
  PENDING_CANDIDATE_ACTION
  PRIVATE
  ACTIVE_MATCHING
  NOT_USING
}

enum ReleaseType {
  CANDIDATE
  EMPLOYER_REQUEST
}

enum LocationType {
  REMOTE
  HYBRID
  IN_PERSON
}

enum ReferralPreference {
  MANUAL_SCREEN
  AUTO_EMAIL
  CONFIDENCE_BASED
}

enum JobPostingStatus {
  DRAFT
  ACTIVE
  FILLED
  CLOSED
}

enum EarningsType {
  REFERRAL_BONUS
  ENDORSEMENT_FEE
  NETWORK_BONUS
  HIRING_COMMISSION
  CLOUT_REWARD
}

enum EarningsStatus {
  PENDING
  CONFIRMED
  PAID
  CANCELLED
  DISPUTED
}

enum CloutActivityType {
  SUCCESSFUL_REFERRAL
  QUALITY_ENDORSEMENT
  NETWORK_INVITATION
  HIRING_MANAGER_SUCCESS
  COMMUNITY_CONTRIBUTION
  TRUST_VALIDATION
  PLATFORM_PROMOTION
  NEGATIVE_FEEDBACK
  SPAM_VIOLATION
}

enum IntroductionStatus {
  PENDING
  ESTABLISHED
  INACTIVE
}

// =============== EIGENTRUST TABLES ===============

// INPUT: Trust allocations (what users assign)
model TrustAllocation {
  id         String   @id @default(cuid())
  giverId    String   // User who is allocating trust
  receiverId String   // User receiving the trust
  proportion Float    // 0.0-1.0, giver's allocations must sum to 1.0
  updatedAt  DateTime @updatedAt @default(now())
  createdAt  DateTime @default(now())

  giver    User @relation("TrustGiver", fields: [giverId], references: [id], onDelete: Cascade)
  receiver User @relation("TrustReceiver", fields: [receiverId], references: [id], onDelete: Cascade)

  @@unique([giverId, receiverId])
  @@map("trust_allocations")
}

// OUTPUT: Computed trust scores (result of algorithm)
model ComputedTrustScore {
  id             String   @id @default(cuid())
  userId         String   @unique
  trustScore     Float    // 0.0-1.0 (raw score from algorithm)
  displayScore   Int      // trustScore * 100 (for UI display)
  rank           Int      // 1, 2, 3, ... (sorted by trustScore)
  iterationCount Int      // How many iterations until convergence
  computedAt     DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("computed_trust_scores")
}

// Logging for debugging
model TrustComputationLog {
  id                   String   @id @default(cuid())
  numUsers             Int
  numIterations        Int      // How many EigenTrust iterations
  convergenceThreshold Float
  decayFactor          Float    // alpha value
  converged            Boolean
  triggeredBy          String   // "manual" | "user_update" | "initialization"
  computedAt           DateTime @default(now())

  @@map("trust_computation_logs")
}
