generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  emailVerified DateTime?
  firstName     String?
  lastName      String?
  profileImage  String?
  phone         String?
  location      String?
  linkedinUrl   String?
  bio           String?
  skills        String[]  @default([])
  experience    String?
  isProfileComplete Boolean @default(false)

  // Referral system (legacy)
  referralCode  String    @unique @default(cuid())
  referredById  String?
  referredBy    User?     @relation("UserReferrals", fields: [referredById], references: [id])
  referrals     User[]    @relation("UserReferrals")

  // Trust-based invitations
  sentInvitations     Invitation[] @relation("InviteSender")
  receivedInvitations Invitation[] @relation("InviteReceiver")

  // Trust relationships (bilateral)
  relationshipsAsUser1 Relationship[] @relation("RelationshipUser1")
  relationshipsAsUser2 Relationship[] @relation("RelationshipUser2")

  // Invite system for initial 100 nodes
  inviteToken   String?   @unique
  inviteUsed    Boolean   @default(false)
  invitedAt     DateTime?

  // Job management (legacy field - now using user_type)
  canCreateJobs Boolean   @default(false)
  ownedJobs     Job[]

  // User intent/mode (keep for now, will migrate data)
  userIntent    UserIntent @default(ACTIVELY_LOOKING)

  // Trust System Properties
  userType         UserType @default(REFERRER)
  engagementLevel  EngagementLevel @default(ACTIVE_SEEKER)  // maps to old userIntent
  tier            NodeTier @default(CONNECTOR)
  availableInvites Int     @default(3)
  totalInvitesUsed Int     @default(0)
  reputationScore  Float   @default(0.0)
  charityDonated   Float   @default(0.0)

  // Clout & Network Earnings
  cloutScore       Float   @default(0.0)     // Overall clout/reputation (0-100)
  totalEarnings    Float   @default(0.0)     // Total USD earned from network
  pendingEarnings  Float   @default(0.0)     // Earnings pending confirmation
  successfulReferrals Int  @default(0)       // Count of successful job placements
  endorsementsScore Float  @default(0.0)     // Score from endorsements received
  networkValue     Float   @default(0.0)     // Value provided to network

  // Job applications/candidacy
  applications  JobApplication[]

  // Endorsement system
  endorsementsGiven     Endorsement[] @relation("EndorsementGiven")
  endorsementsReceived  Endorsement[] @relation("EndorsementReceived")
  endorsementReleases   EndorsementRelease[]

  // Hiring manager capabilities
  isHiringManager       Boolean @default(false)

  // Authentication
  accounts      Account[]
  sessions      Session[]

  // Clout & Earnings tracking
  earningsTransactions EarningsTransaction[]
  cloutActivities      CloutActivity[]

  // Professional introductions (as person A, B, or introducer)
  introductionsAsPersonA   Introduction[] @relation("IntroductionPersonA")
  introductionsAsPersonB   Introduction[] @relation("IntroductionPersonB")
  introductionsMade        Introduction[] @relation("IntroductionMaker")

  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@map("users")
}

model Invitation {
  id           String   @id @default(cuid())
  email        String   // Email of person being invited
  trustScore   Int      // 1-10 trust score (immutable once set)
  status       InvitationStatus @default(PENDING)

  senderId     String
  sender       User     @relation("InviteSender", fields: [senderId], references: [id])

  receiverId   String?  // Null until invitation is accepted
  receiver     User?    @relation("InviteReceiver", fields: [receiverId], references: [id])

  sentAt       DateTime @default(now())
  respondedAt  DateTime?

  @@unique([senderId, email]) // Prevent duplicate invitations
  @@map("invitations")
}

model Relationship {
  id           String   @id @default(cuid())

  user1Id      String
  user1        User     @relation("RelationshipUser1", fields: [user1Id], references: [id])

  user2Id      String
  user2        User     @relation("RelationshipUser2", fields: [user2Id], references: [id])

  // Trust scores from each user's perspective (mutable)
  user1TrustScore Int   // How much user1 trusts user2 (1-10)
  user2TrustScore Int   // How much user2 trusts user1 (1-10)

  status       RelationshipStatus @default(PENDING)

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@unique([user1Id, user2Id]) // Prevent duplicate relationships
  @@map("relationships")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

model Company {
  id          String @id @default(cuid())
  name        String
  description String?
  website     String?
  logoUrl     String?
  industry    String?
  size        String?

  jobs        Job[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("companies")
}

model Job {
  id           String @id @default(cuid())

  // Basic job information
  title        String
  locationType LocationType @default(REMOTE)
  locationCity String?
  salaryMin    Int?
  salaryMax    Int?
  currency     String @default("USD")
  equityOffered Boolean @default(false)
  equityRange  String?
  dayToDayDescription String? @db.Text

  // Questionnaire-based fields
  archetypes   String? @db.Text  // Who would excel in this role
  nonWorkSignals String? @db.Text  // Non-work experiences that signal fit
  flexibleRequirements String? @db.Text  // What they're flexible on
  commonMismatches String? @db.Text  // Who would struggle despite looking good on paper
  roleChallenges String? @db.Text  // What people underestimate about the role
  workingStyle String? @db.Text  // Team's working style
  excitingWork String? @db.Text  // Problems/projects that get them excited
  specialOpportunity String? @db.Text  // Why someone should join beyond salary
  growthPath   String? @db.Text  // Growth path for the role
  mustHaves    String? @db.Text  // Actual non-negotiables (keep short)

  // Referral settings
  referralBudget Int?
  referralPreference ReferralPreference @default(MANUAL_SCREEN)

  // Legacy fields (for backward compatibility)
  description  String? @db.Text
  requirements String[] @default([])
  location     String?
  remote       Boolean @default(false)

  // Status and metadata
  status       JobPostingStatus @default(DRAFT)
  publishedAt  DateTime?

  companyId    String
  company      Company @relation(fields: [companyId], references: [id])

  ownerId      String
  owner        User @relation(fields: [ownerId], references: [id])

  applications JobApplication[]
  endorsementReleases EndorsementRelease[]

  // Clout & Earnings tracking
  earningsTransactions EarningsTransaction[]
  cloutActivities      CloutActivity[]

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@map("jobs")
}

model JobApplication {
  id        String @id @default(cuid())
  status    ApplicationStatus @default(APPLIED)

  userId    String
  user      User @relation(fields: [userId], references: [id])

  jobId     String
  job       Job @relation(fields: [jobId], references: [id])

  appliedAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, jobId])
  @@map("job_applications")
}

enum JobStatus {
  ACTIVE
  PAUSED
  CLOSED
}

enum ApplicationStatus {
  APPLIED
  REVIEWING
  INTERVIEWING
  OFFERED
  REJECTED
  WITHDRAWN
}

enum UserIntent {
  RECOMMEND_ONLY
  HYBRID
  ACTIVELY_LOOKING
}

enum UserType {
  CLIENT      // Can create jobs
  REFERRER    // Regular network node
}

enum EngagementLevel {
  PURE_REFERRER   // Only recommends others
  HYBRID          // Refers + considers opportunities
  ACTIVE_SEEKER   // Actively looking for jobs
}

enum NodeTier {
  CONNECTOR      // 3 invites
  TALENT_SCOUT   // 5 invites
  NETWORK_HUB    // 10 invites
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  DECLINED
  EXPIRED
}

enum RelationshipStatus {
  PENDING     // Waiting for other party confirmation
  CONFIRMED   // Both parties have confirmed
  DECLINED    // Other party declined
}

model Endorsement {
  id                  String   @id @default(cuid())

  endorserId          String
  endorser            User     @relation("EndorsementGiven", fields: [endorserId], references: [id])

  endorsedUserId      String?  // Null until candidate joins platform
  endorsedUser        User?    @relation("EndorsementReceived", fields: [endorsedUserId], references: [id])

  endorsedUserEmail   String   // Email of person being endorsed
  endorsementContent  String   @db.Text // The full endorsement from Typeform
  videoUrl            String?  // Optional video endorsement URL

  status              EndorsementStatus @default(PENDING_CANDIDATE_ACTION)
  candidateNotifiedAt DateTime?
  candidateRespondedAt DateTime?

  releases            EndorsementRelease[]
  cloutActivities     CloutActivity[]

  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  @@unique([endorserId, endorsedUserEmail]) // Prevent duplicate endorsements
  @@map("endorsements")
}

model EndorsementRelease {
  id              String   @id @default(cuid())

  endorsementId   String
  endorsement     Endorsement @relation(fields: [endorsementId], references: [id], onDelete: Cascade)

  employerId      String
  employer        User     @relation(fields: [employerId], references: [id])

  jobId           String?  // Optional specific job
  job             Job?     @relation(fields: [jobId], references: [id])

  releasedBy      ReleaseType
  releasedAt      DateTime @default(now())

  @@map("endorsement_releases")
}

model EarningsTransaction {
  id              String   @id @default(cuid())

  userId          String
  user            User     @relation(fields: [userId], references: [id])

  amount          Float    // USD amount earned
  type            EarningsType
  status          EarningsStatus @default(PENDING)

  // Related job/referral info
  jobId           String?
  job             Job?     @relation(fields: [jobId], references: [id])

  // Description and metadata
  description     String?  // Human readable description
  metadata        Json?    // Additional data (candidate info, etc.)

  // Payment tracking
  paidAt          DateTime?
  paymentMethod   String?  // "bank_transfer", "paypal", etc.

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@map("earnings_transactions")
}

model CloutActivity {
  id              String   @id @default(cuid())

  userId          String
  user            User     @relation(fields: [userId], references: [id])

  activity        CloutActivityType
  pointsAwarded   Float    // Clout points gained/lost
  description     String   // What happened

  // Related entities
  jobId           String?
  job             Job?     @relation(fields: [jobId], references: [id])

  endorsementId   String?
  endorsement     Endorsement? @relation(fields: [endorsementId], references: [id])

  createdAt       DateTime @default(now())

  @@map("clout_activities")
}

enum EndorsementStatus {
  PENDING_CANDIDATE_ACTION  // Endorsement written, waiting for candidate to choose
  PRIVATE                   // Candidate will release to specific employers case-by-case
  ACTIVE_MATCHING          // Clout can proactively share with relevant employers
  NOT_USING                // Candidate chose not to activate this endorsement
}

enum ReleaseType {
  CANDIDATE         // Released by candidate
  EMPLOYER_REQUEST  // Released via employer request
}

enum LocationType {
  REMOTE
  HYBRID
  IN_PERSON
}

enum ReferralPreference {
  MANUAL_SCREEN      // Screen every referral before reaching out
  AUTO_EMAIL         // Auto-email referred candidates
  CONFIDENCE_BASED   // Different preferences based on referrer confidence level
}

enum JobPostingStatus {
  DRAFT     // Job saved but not published
  ACTIVE    // Job published and accepting referrals
  FILLED    // Position has been filled
  CLOSED    // Job posting closed
}

enum EarningsType {
  REFERRAL_BONUS      // Payment for successful job referral
  ENDORSEMENT_FEE     // Payment for writing endorsement
  NETWORK_BONUS       // Bonus for network growth/activity
  HIRING_COMMISSION   // Commission from hiring manager fees
  CLOUT_REWARD        // Reward for high clout/reputation
}

enum EarningsStatus {
  PENDING             // Awaiting confirmation/approval
  CONFIRMED           // Approved for payment
  PAID                // Payment completed
  CANCELLED           // Transaction cancelled
  DISPUTED            // Payment under dispute
}

enum CloutActivityType {
  SUCCESSFUL_REFERRAL      // Made a successful job referral
  QUALITY_ENDORSEMENT      // Wrote high-quality endorsement
  NETWORK_INVITATION       // Invited valuable new member
  HIRING_MANAGER_SUCCESS   // Successful hiring as hiring manager
  COMMUNITY_CONTRIBUTION   // Contributed to community (help, feedback)
  TRUST_VALIDATION        // Helped validate trust relationships
  PLATFORM_PROMOTION      // Promoted platform externally
  NEGATIVE_FEEDBACK       // Received negative feedback (loses clout)
  SPAM_VIOLATION          // Spamming or policy violation (loses clout)
}

enum IntroductionStatus {
  PENDING        // Introduction made, neither has acknowledged
  ESTABLISHED    // They've acknowledged/connected
  INACTIVE       // Introduction didn't lead to connection
}

model Introduction {
  id            String   @id @default(cuid())

  // The two people being introduced (ordered consistently: lower ID first)
  personAId     String
  personA       User     @relation("IntroductionPersonA", fields: [personAId], references: [id])

  personBId     String
  personB       User     @relation("IntroductionPersonB", fields: [personBId], references: [id])

  // Who made the introduction (typically Clout admin)
  introducedById String
  introducedBy   User     @relation("IntroductionMaker", fields: [introducedById], references: [id])

  // Context and metadata
  context        String   @db.Text  // Why the intro was made
  status         IntroductionStatus @default(PENDING)
  notes          String?  @db.Text  // User notes about the connection

  // Timestamps
  createdAt      DateTime @default(now())
  establishedAt  DateTime?  // When marked as established
  updatedAt      DateTime @updatedAt

  // Prevent duplicate introductions (ensure personAId < personBId during insert)
  @@unique([personAId, personBId])
  @@map("introductions")
}
